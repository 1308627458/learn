# 1. 浏览器是如何获取到资源的
  1. 确定目标服务器的IP地址
  2. 和该服务器建立链接  （TCP 三次握手）
  3. 和该服务器进行数据传输  （HTTP）
  4. 和该服务器断开连接 （TCP 四次挥手）


# IP协议 （确定目标服务器的IP地址）
  - DNS解析
    1. 向本地域名服务器询问 www.baidu.com 对应的IP是多少
    2. 向根域名服务器（root）询问 xxx
    3. 向顶级（.com）域名服务器询问 xxx
    4. 向 baidu.com域名服务器 询问 xxx   // 47.27.123.10

# UDP 协议
  1. 面向无连接的
  2. 只是数据报文的搬运工
  3. 不保证有序且不丢失
  4. 没有控制流量的算法（拥塞控制）

  - 面向无连接
    不需要向tcp一样建立连接，想发数据就可以直接发

  - 不可靠性
    1. 无连接
    2. 拿到什么数据有传输什么数据，也不备份，也不关系对象是否已经明确接收到
    3. 网络环境时好时坏，UDP没有拥塞控制，一直一一个恒定的速度发送数据，一旦网络环境差，就几容易发生数据包丢失

  - 高效
    UDP头只有8字节，很小，没有其他复杂的操作，传输效率高。在一些实时性要求高的场景中被使用

# TCP 协议
  1. 面向有连接的
  2. 在传输的过程中，通过各种算法保证了数据的可靠性
  3. 有拥塞控制

  - 头部标记：
    Sequence number: 序号，接收端课根据这个序号来拼接报文
    Acknowledgement Number: 表示接受端期望接收到的下一个字节编号是多少
    Window Size: 还能接受多少字节的数据，用于流量控制
    标识符：
      URG=1：紧急数据，传输的优先级最高
      ACK=1：确认编号字段有效
      PSH=1：接收端应该立即将接收到的数据提交给应用层使用
      RST=1：TCP链接出现问题，需要重连
      SYN=1，ACK=0：请求报文    SYN=1，ACK=1：应答报文
      FIN=1：数据传输完毕，释放连接

# 三次握手

  - 为什么两次握手不够？
    假设客户端向服务端发送一个建立连接请求A,因为网络原因A没有被服务端接收到，那么TCP会启用超时重传机制，重新发送建立连接的请求B，当B被服务端接收到且服务端应答后，就开始数据传输，然后断开连接。如果连开连接后，请求A又抵达了服务端，那么服务端会误以为是客户端和它建立连接，于是会再次应答，且变更自己的状态，可是客户端已经closed，那么服务端状态一直等待，带来了资源浪费

# 四次挥手（断开连接）
  1. 客户端向服务端发送释放连接的请求
  2. 服务端将还没有传输完的数据继续传输
  3. 服务端向客户端发送释放连接的应答
  4. 客户端向服务端发送确认应答(2MSL 后进入COLSED状态)

# 为什么客户端一定要进入TIMW-WAIT状态？2MSL 存在的意义？
  为了保证服务端一定能收到客户端的应答，如果客户端发完确认应答后直接进入CLOSED状态，一旦网络环境不好，服务端没有接收到应答，服务端就无法关闭，造成资源浪费





