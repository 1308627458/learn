# 1.js 数组的常用方法有哪些？
  - 增删改
  push, pop, shift, unshift, slice(从数组中截取指定位置的元素，返回一个新数组，不改变原数组), splice(返回被删除的元素组成的数组，改变原数组), concat
  - 遍历
  forEach     (没有返回值), 
  filter    (用于筛选，过滤数组中满足条件的元素，返回一个新数组), 
  every (判断数组中元素是否全部符合条件), 
  some   (判断数组中有没有符合条件的,只要找到一个符合条件，就会返回true 并不会全部遍历，性能优良), 
  map, (一一映射)
  reduce(用于将数组中的所有元素按照指定规则进行归并计算，返回一个最终值，接受两个参数，一个回调函数，和一个初始值，回调函数接受四个参数，1-初始值或上一次回调函数叠加的值，2-本次回调将要执行的值，3-索引值， 4-数组本身),


  - 排序
    sort  (用于对数组进行排序，会直接修改原数组，可以传入自定义的比较函数来基于其他规则排序),  arr.sort((a, b) => a - b)---从小到大，   arr.sort((a, b) => b - a)--- 从大到小
    reverse (用于反转数组中元素的顺序)
  - 查找
  indexOf   (返回第一个匹配项的下标，找不到返回 -1，可接收参数，从哪个位置开始查找), 
  lastIndexOf   (查找某个元素最后一次出现的索引), 
  includes    (检查数组中是否包含某个元素，有返回true，没有返回false), 
  findIndex   (查找数组中满足条件元素的索引，找到返回第一个符合条件的元素下标，否则返回-1), 
  find   (查找数组中满足条件的元素，并返回第一个符合条件的元素)

  join(将数组中所有元素以指定的分隔符连接成一个字符串) , fill(填充一个数组中的所有元素，会直接修改原数组)
# 2. js字符串的常用方法有哪些
  - 增: concat 
  - 删: slice, substr, substring, 
  - 改: toUpperCase, toLowerCase, repeat(2), trim
  - 查: indexOf, includes, startsWith, endsWith, charAt(n)

  - 转换方法: split('')
  - 匹配: replace, search(正则), match(正则)

# 3. 谈谈js 中的类型转化机制
  - 概述：
  基本类型：string number boolean undefined null symbol bigInt 
  引用类型： object 

  - 显示转换: 人为的转换

  - 隐式转换: 
  1. 原始类型 => 原始类型
  2. 引用类型 => 原始类型
      - 四则运算： + - * / % == !=
      - 条件语句：if while > < 
  - ToPrimitive(obj) 执行过程
  1. 判断obj是否原始值，是则返回
  2. 调用valueOf(obj)

# 4. == 和 === 的区别?
    == 是只判断值是否相等，会发生隐式类型转化
    === 不发生隐式类型转化，判断值相等

# 5. 说说深拷贝和浅拷贝，如何实现一个深拷贝？
  - 是什么
    因为在js中，基本数据类型式保存在栈中，而引用类型式保存在堆当中(指针在栈中)，所以深拷贝和浅拷贝通常只针引用类型来讨论

    浅拷贝： 拷贝原对象，新对象会受原对象修改的影响
    深拷贝： 拷贝原对象，新的对象不会受原对象修改的影响

  - 常见的深浅拷贝方法：
    浅拷贝：Object.assign(), {...obj},slice(0), concat(arr), [...arr]
    深拷贝：JSON.parse(JSON.stringify(obj)) --- (不能拷贝 undefined, symbol, 函数，正则，NaN, Infinity, Date, 不能处理循环引用)

  - 


# 6. 说说你对闭包的理解
  - 是什么
    当调用一个外部函数返回的一个内部函数时，即使外部函数执行完毕，但内部函数引用外部函数的变量，那么这些变量依然会被保存在内存中，我们吧这个变量的集合称之为闭包。

  - 使用场景
    1. 创建私有变量
    2. 延长变量的生命周期

  - 缺点
    会导致内存泄露

# 7. 说说你对作用域的理解
  - 是什么
    变量(上下文) 和函数生效的区域，作用域决定了该区域中的变量和资源的可见性，

  - 有哪几种作用域
    1. 全局作用域 
    2. 函数作用域
    3. 块级作用域: let, const 

  - 作用域链
    在js中，当需要查找一个变量时，js引擎会在当前作用域中查找该变量，如果找不到，就会去上层作用域中查找，直到找到变量或者来到全局作用域下，这种查找关系就称之为作用域链
  
# 8. 说说你对原型，原型链的理解
  - 是什么 
    在js中， 对象具有__proto__属性， 称之为对象原型(隐式原型)，它等于创建该对象的构造函数的显示原型(prototype)

   函数具有prototype属性，我们称之为显示原型(原型)，它是一个对象，在它内部添加的属性会被函数的实例对象所继承

  对象在查找属性时，会先在自己显示属性上查找，找不到再去对象原型上查找，层层往上，直到找到该属性或者达到原型链的末端

  - 原型链：
    对象的原型也是对象，还有原型。对象在原型上层层查找属性的这种链状关系，就称之为原型链，原型链末端是 Object.prototype

# 9. 说说js中的继承
  - 是什么
  是一种可以让 类A访问到B类中所有的属性方法的手段

  - 实现方式
    1. class extends
    2. 原型链继承 // 修改子类的原型让它等于父类的实例对象
    3. 构造函数继承 
    4. 组合继承
    5. 寄生组合继承


# 10. 说说你对js中this的理解
  - 是什么
    js中提供的一个函数运行时的关键字， 用来指代某个区域的作用域，总能指向调用它的对象
  - 作用

  - 绑定规则
    1. 默认绑定
    2. 隐式绑定
    3. 隐式丢失
    4. 显示绑定： call apply bind
    5. new绑定： this 指向实例对象

  - 箭头函数
    箭头函数没有this这个概念，即使在箭头函数中写了this,那么也代表的是箭头函数外层的非箭头函数的this

# 11. 说说你对js中执行上下文和执行栈的理解
  - 是什么
    执行栈：是js引擎在编译js代码环节维护的一个栈结构，用来存放各个执行上下文对象

    执行上下文：全局执行上下文，函数体执行上下文，是js引擎梳理当前环境下的资源访问关系的一个对象

    - 生命周期
      函数编译(创建) -> 函数执行(执行) -> 回收

    1. 创建：确定this值，创建词法环境，创建变量环境
    2. 执行：变量赋值，代码执行
    3. 回收：执行上下文出栈的过程 (垃圾回收机制)


# 12. 谈谈js中的事件模型
  - 事件流
    js中的各种事件执行都存在一个传播的过程，这个过程会经历三个阶段，事件的捕获阶段，处于目标阶段，事件的冒泡阶段

  - 事件模型
  1. 原始事件模型(DOM0)： 兼容性最好，只能同时绑定一个事件，没有捕获，没有处于目标阶段，只有冒泡
  2. IE事件模型：(基本不适用 attachEvent) 只有目标阶段和冒泡阶段
  3. 标准事件模型(DOM1)： 兼容性良好，能同时绑定多个事件，有捕获，处于目标阶段和冒泡

# 13. typeof 和 instanceof 的区别
  - typeof 可以判断除了 null 之外的所有原始类型，得到一个字符串
  - instanceof 用来判断引用类型, 根据对象的隐式原型是否等于构造函数的显示原型来判断，得到一个布尔值

# 14. 说说什么是事件代理，应用场景
  - 是什么 
    借助冒泡机制，将原本应该绑定在目标容器上的事件，绑定到它外层容器上
  
  - 应用场景
    1. 减少整体页面需要注册的函数的数量，提升性能，主要在当子容器是循环生成的时候需要注册事件时
  
# 15. 说说 new 操作符都干了些什么
  1. 创建一个新对象
  2. 将对象的隐式原型赋值为函数的原型
  3. 将函数的this指向该对象
  4. 执行该函数
  5. 返回创建的对象


# 16. Ajax原理
- (Async JavaScript and XML)
  1. 借助 XMLHttpRequest 创建请求对象
  2. 封装get post... 等请求方式
  3. 处理参数的传递
  4. 监听请求对象的状态变化来获取响应数据

# 17. 说说你对js的事件循环的理解
  - 是什么
  因为js是单线程的，单线程会存在 阻塞 问题，所有引入了一种循环执行机制，称之为event-loop

  - event-loop
  1. 判断同步和异步，执行同步代码(属于宏任务)
  2. 调用栈空出来后，查找是否有异步任务需要执行
  3. 执行异步中的 微任务
  4. 渲染页面(有需要的情况下)
  5. 执行宏任务(相当于是下一次的event-loop开始)

  - 微任务：
    1. Promise.then
    2. await()
    3. process.nextTick
    4. MutationObserver

  - 宏任务：
  1. script
  2. setTimeout / setInterval / setImmediate
  3. ui-rendering
  4. I/O
  5. MessageChannel, postMessage

# 18. 说说正则表达式
  - 是什么
    是一个可以匹配字符串的特殊对象，包含test, match, replace等方法

  - 检验用书输入的账号，是否满足该种账号的特征

# 19. 说说你对DOM的理解，常见的操作的有哪些？
  - 是什么
    DOM: 文档对象，主要定义了一种方式可以使从程序
    把文档当成对象来看待
    DOM的顶级是doucument
    W3C的标准

  - 节点类型：
    1. 元素节点 createElement   createDocumentFragment
    2. 属性节点 createAttribute
    3. 文本节点 createTextNode  innerHTML  innerText

# 20. 说说你对 BOM 的理解， 常见的BOM对象有哪些？
  - 是什么
    浏览器对象模型，是一个提供内容和浏览器窗口交互的对象
    把浏览器当成对象来看待
    BOM的顶级window
    浏览器自己定义标准

    - BOM包含：
     1. window
     2. location
     3. navigator
     4. screen
     5. history

# 21. 说说你对尾递归的理解
  - 在尾部调用函数自身
  - 因为不使用上一层函数中的变量，所以不需要再调用栈中存储上一层函数，复杂度为o(1)

# 22. js中本地存储的方式有哪些？有什么区别？应用场景？
  1. localStorage   (适合长期存储的数据，比如数据令牌)
    - 永久
    - 5M
    - 前端操作

  2. cookie  (标记用户，跟踪用户的行为)
    - 后端可设置
    - 4kb
    - 服务端操作，可以自动传递到服务端
  3. sessionStorage (敏感的数据，例如账号密码)
    - 会话维持期间
    - 5M
    - 客户端操作
  4. indexedDB   (大量数据存储，比如:在线文档编辑保存)
    - 永久
    - 无限大 (借助机械硬盘)
    - 客户端操作

# 23. 说说你对函数式编程的理解？优缺点
  - 主要是编程范式：
    1. 命令式编程
    2. 声明式编程
    3. 函数式编程

  - 把逻辑过程写成函数，定义好参数，只需要关心输出结果，旨在尽可能的提高代码的无状态和不变性

  - 纯函数
    1. 无状态 + 数据不可变
    2. 不依赖外部环境， 不会产生副作用，提高了复用性
    
  - 高阶函数
    1. 以函数作为输入或输出的函数
    2. 通常用高阶函数的手段来修饰一个普通函数的执行
    
  - 柯里化
    1. 把一个接受多个参数的函数，拆分成多个只接受一个参数的函数
    2. 让函数更纯粹，耦合度更低，惰性执行

  - 组合函数 
    将多个函数组合成一个函数，可以整合多个小函数，来完成更复杂的逻辑


# 24. js中如何实现函数缓存？
缓存函数的运算结果

# 25. 说说js数字精度丢失的问题，解决方法？
精度丢失通常发生在浮点数的运算当中，在js中主流数字是Number类型，而Number类型采用的是 IEEE754 规范中的64位双精度浮点数编码

X = a * 2^e

8字节，64位比特

# 26. 说说防抖节流有什么区别？怎么实现？